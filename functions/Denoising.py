import numpy as np
import itertools as it
from io_data import read_data,write_data

def sigmoid(x):
    return 1/(1+np.exp(-x))

def normal(y,mu,sigma):
    """Normal Distribution Density"""
    return (np.exp(-(y-mu)**2/2*sigma**2)/np.sqrt(2*np.pi*sigma**2))


def normalize_img(image):
    """ Takes as an input an image and format it in order to be used in the Ising model"""
    image = image.reshape(image.shape[0], -1)
    image[image==0] = -1
    image[image==255] = 1
    return image

def unnormalize_avg_img(image_list):
    """Takes as input the list of image states generated by gibbs sampling,
     maps them back to {0,255} and affect them to the most likely states through average"""
    image_list[image_list == 1] = 255
    image_list[image_list == -1] = 0
    image_avg = np.average(image_list, axis=0)
    image_avg[image_avg > 127.5] = 255
    image_avg[image_avg <= 127.5] = 0
    image_avg = image_avg.reshape(image_avg.shape[0],image_avg.shape[1],1)
    return image_avg

def img_to_data(image):
    """ Post-processing to be able to save and generate .jpg images using the [data] format """
    data = []
    r,c = (image.shape[0],image.shape[1])
    for i in it.product(np.arange(c),np.arange(r)):
        data.append(list(i)+list([image[i[1],i[0]]]))
    return np.array(data).reshape(-1,3)



def neighbors_ix(pos,image):
    """ Returns an array of neighboring indices of [pos] in [image]"""
    nbrs = np.array([[1,0],[0,1],[-1,0],[0,-1]])
    pos_nbrs =[]
    dim = (image.shape[0]-1,image.shape[1]-1)
    for i in range(4):
        if not (np.clip(pos+nbrs[i],0,dim)==pos).all():
            pos_nbrs.append(np.clip(pos+nbrs[i],0,dim))
    return pos_nbrs


def gibbs(X0,Beta,Y,sigma,niter=10):
    """ Following the calculations in the report,
     returns a list of images which pixels are sampled from p"""
    X_list = [X0]
    X = X0.copy()
    r,c = Y.shape
    positions = list(it.product(np.arange(r),np.arange(c)))
    np.random.shuffle(positions)
    for n in range(niter):
        Z = X_list[n].copy()
        for i in positions:
            s = sum([Z[j[0],j[1]] for j in neighbors_ix(i,Z)])
            p= sigmoid(2*Beta*s+np.log(normal(Y[i[0],i[1]],1,sigma)/normal(Y[i[0],i[1]],-1,sigma)))
            X[i[0],i[1]] = np.random.choice([1,-1],1,p = [p,1-p])
        X_list = np.append(X_list,[X],axis=0)
        if (n+1)%step==0:
            print("iter: {}".format(n+1))
    return X_list


#Importing data and initializing the parameters
data,image = read_data("../a1/4_noise.txt",True)
Y = normalize_img(image)
r,c = Y.shape
X0 = np.zeros(Y.shape)
Beta = 8
nbiter = 10
step = max(int(nbiter/100),1)
sigma = 3.5

#Image denoising
X_list = gibbs(X0,Beta,Y,sigma,nbiter)[2:]
X_avg = unnormalize_avg_img(X_list)

#Output
write_data(img_to_data(X_avg), "../outputs/a1/4_output_5.txt")
read_data("../outputs/a1/4_output_5.txt", True, save=True)












